import {
  INTENT,
  STATE,
  createFormContext,
  formatPaths,
  getPaths,
  isPrefix,
  parse
} from "./chunk-PZSOEYJK.js";
import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@conform-to/react/_virtual/_rollupPluginBabelHelpers.mjs
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/@conform-to/react/context.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Form = (0, import_react.createContext)([]);
var wrappedSymbol = Symbol("wrapped");
function getWrappedFormContext(context) {
  return context[wrappedSymbol];
}
function useFormContext(formId) {
  var contexts = (0, import_react.useContext)(Form);
  var form = formId ? contexts.find((context) => formId === context.getFormId()) : contexts[0];
  if (!form) {
    throw new Error("Form context is not available");
  }
  return form;
}
function useFormState(form, subjectRef) {
  var subscribe = (0, import_react.useCallback)((callback) => form.subscribe(callback, () => subjectRef === null || subjectRef === void 0 ? void 0 : subjectRef.current), [form, subjectRef]);
  return (0, import_react.useSyncExternalStore)(subscribe, form.getState, form.getState);
}
function FormProvider(props) {
  var forms = (0, import_react.useContext)(Form);
  var context = getWrappedFormContext(props.context);
  var value = (0, import_react.useMemo)(
    () => [context].concat(forms),
    // Put the latest form context first
    [forms, context]
  );
  return (0, import_jsx_runtime.jsx)(Form.Provider, {
    value,
    children: props.children
  });
}
function FormStateInput(props) {
  var context = useFormContext(props.formId);
  return (0, import_jsx_runtime.jsx)("input", {
    type: "hidden",
    name: STATE,
    value: context.getSerializedState(),
    form: props.formId
  });
}
function useSubjectRef() {
  var initialSubject = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var subjectRef = (0, import_react.useRef)(initialSubject);
  subjectRef.current = initialSubject;
  return subjectRef;
}
function updateSubjectRef(ref, subject, scope, name) {
  if (subject === "status" || subject === "formId") {
    ref.current[subject] = true;
  } else if (typeof scope !== "undefined" && typeof name !== "undefined") {
    var _ref$current$subject$, _ref$current$subject;
    ref.current[subject] = _objectSpread2(_objectSpread2({}, ref.current[subject]), {}, {
      [scope]: ((_ref$current$subject$ = (_ref$current$subject = ref.current[subject]) === null || _ref$current$subject === void 0 ? void 0 : _ref$current$subject[scope]) !== null && _ref$current$subject$ !== void 0 ? _ref$current$subject$ : []).concat(name)
    });
  }
}
function getMetadata(context, subjectRef, stateSnapshot) {
  var name = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
  var id = name ? "".concat(context.getFormId(), "-").concat(name) : context.getFormId();
  var state = context.getState();
  return new Proxy({
    id,
    name,
    errorId: "".concat(id, "-error"),
    descriptionId: "".concat(id, "-description"),
    get initialValue() {
      return state.initialValue[name];
    },
    get value() {
      return state.value[name];
    },
    get errors() {
      return state.error[name];
    },
    get key() {
      return state.key[name];
    },
    get valid() {
      return state.valid[name];
    },
    get dirty() {
      return state.dirty[name];
    },
    get allErrors() {
      if (name === "") {
        return state.error;
      }
      var result = {};
      for (var [key, error] of Object.entries(state.error)) {
        if (isPrefix(key, name)) {
          result[key] = error;
        }
      }
      return result;
    },
    get getFieldset() {
      return () => new Proxy({}, {
        get(target, key, receiver) {
          if (typeof key === "string") {
            return getFieldMetadata(context, subjectRef, stateSnapshot, name, key);
          }
          return Reflect.get(target, key, receiver);
        }
      });
    }
  }, {
    get(target, key, receiver) {
      if (state === stateSnapshot) {
        switch (key) {
          case "id":
          case "errorId":
          case "descriptionId":
            updateSubjectRef(subjectRef, "formId");
            break;
          case "key":
          case "initialValue":
          case "value":
          case "valid":
          case "dirty":
            updateSubjectRef(subjectRef, key, "name", name);
            break;
          case "errors":
          case "allErrors":
            updateSubjectRef(subjectRef, "error", key === "errors" ? "name" : "prefix", name);
            break;
        }
      }
      return Reflect.get(target, key, receiver);
    }
  });
}
function getFieldMetadata(context, subjectRef, stateSnapshot) {
  var prefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
  var key = arguments.length > 4 ? arguments[4] : void 0;
  var name = typeof key === "undefined" ? prefix : formatPaths([...getPaths(prefix), key]);
  return new Proxy({}, {
    get(_, key2, receiver) {
      var _state$constraint$nam;
      var metadata = getMetadata(context, subjectRef, stateSnapshot, name);
      var state = context.getState();
      switch (key2) {
        case "formId":
          if (state === stateSnapshot) {
            updateSubjectRef(subjectRef, "formId");
          }
          return context.getFormId();
        case "required":
        case "minLength":
        case "maxLength":
        case "min":
        case "max":
        case "pattern":
        case "step":
        case "multiple":
          return (_state$constraint$nam = state.constraint[name]) === null || _state$constraint$nam === void 0 ? void 0 : _state$constraint$nam[key2];
        case "getFieldList": {
          return () => {
            var _state$initialValue$n;
            var initialValue = (_state$initialValue$n = state.initialValue[name]) !== null && _state$initialValue$n !== void 0 ? _state$initialValue$n : [];
            if (state === stateSnapshot) {
              updateSubjectRef(subjectRef, "initialValue", "name", name);
            }
            if (!Array.isArray(initialValue)) {
              throw new Error("The initial value at the given name is not a list");
            }
            return Array(initialValue.length).fill(0).map((_2, index) => getFieldMetadata(context, subjectRef, stateSnapshot, name, index));
          };
        }
      }
      return Reflect.get(metadata, key2, receiver);
    }
  });
}
function getFormMetadata(context, subjectRef, stateSnapshot, noValidate) {
  return new Proxy({}, {
    get(_, key, receiver) {
      var metadata = getMetadata(context, subjectRef, stateSnapshot);
      var state = context.getState();
      switch (key) {
        case "context":
          return {
            [wrappedSymbol]: context
          };
        case "status":
          if (state === stateSnapshot) {
            updateSubjectRef(subjectRef, "status");
          }
          return state.submissionStatus;
        case "validate":
        case "update":
        case "reset":
        case "insert":
        case "remove":
        case "reorder":
          return context[key];
        case "onSubmit":
          return context.submit;
        case "noValidate":
          return noValidate;
      }
      return Reflect.get(metadata, key, receiver);
    }
  });
}
function createFormContext2(options) {
  var {
    onSubmit
  } = options;
  var context = createFormContext(options);
  return _objectSpread2(_objectSpread2({}, context), {}, {
    submit(event) {
      var submitEvent = event.nativeEvent;
      var result = context.submit(submitEvent);
      if (!result.submission || result.submission.status === "success" || result.submission.error === null) {
        if (!result.formData.has(INTENT)) {
          var _onSubmit;
          (_onSubmit = onSubmit) === null || _onSubmit === void 0 || _onSubmit(event, result);
        }
      } else {
        event.preventDefault();
      }
    },
    onUpdate(options2) {
      onSubmit = options2.onSubmit;
      context.onUpdate(options2);
    }
  });
}

// node_modules/@conform-to/react/hooks.mjs
var import_react2 = __toESM(require_react(), 1);
var _excluded = ["id"];
var useSafeLayoutEffect = typeof document === "undefined" ? import_react2.useEffect : import_react2.useLayoutEffect;
function useFormId(preferredId) {
  var id = (0, import_react2.useId)();
  return preferredId !== null && preferredId !== void 0 ? preferredId : id;
}
function useNoValidate() {
  var defaultNoValidate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  var [noValidate, setNoValidate] = (0, import_react2.useState)(defaultNoValidate);
  useSafeLayoutEffect(() => {
    if (!noValidate) {
      setNoValidate(true);
    }
  }, [noValidate]);
  return noValidate;
}
function useForm(options) {
  var {
    id
  } = options, formConfig = _objectWithoutProperties(options, _excluded);
  var formId = useFormId(id);
  var [context] = (0, import_react2.useState)(() => createFormContext2(_objectSpread2(_objectSpread2({}, formConfig), {}, {
    formId
  })));
  useSafeLayoutEffect(() => {
    var disconnect = context.observe();
    document.addEventListener("input", context.onInput);
    document.addEventListener("focusout", context.onBlur);
    document.addEventListener("reset", context.onReset);
    return () => {
      disconnect();
      document.removeEventListener("input", context.onInput);
      document.removeEventListener("focusout", context.onBlur);
      document.removeEventListener("reset", context.onReset);
    };
  }, [context]);
  useSafeLayoutEffect(() => {
    context.onUpdate(_objectSpread2(_objectSpread2({}, formConfig), {}, {
      formId
    }));
  });
  var subjectRef = useSubjectRef();
  var stateSnapshot = useFormState(context, subjectRef);
  var noValidate = useNoValidate(options.defaultNoValidate);
  var form = getFormMetadata(context, subjectRef, stateSnapshot, noValidate);
  return [form, form.getFieldset()];
}
function useFormMetadata(formId) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var subjectRef = useSubjectRef();
  var context = useFormContext(formId);
  var stateSnapshot = useFormState(context, subjectRef);
  var noValidate = useNoValidate(options.defaultNoValidate);
  return getFormMetadata(context, subjectRef, stateSnapshot, noValidate);
}
function useField(name) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var subjectRef = useSubjectRef();
  var context = useFormContext(options.formId);
  var stateSnapshot = useFormState(context, subjectRef);
  var field = getFieldMetadata(context, subjectRef, stateSnapshot, name);
  var form = getFormMetadata(context, subjectRef, stateSnapshot, false);
  return [field, form];
}

// node_modules/@conform-to/react/integrations.mjs
var import_react3 = __toESM(require_react(), 1);
function getFormElement(formId) {
  return document.forms.namedItem(formId);
}
function getFieldElements(form, name) {
  var field = form === null || form === void 0 ? void 0 : form.elements.namedItem(name);
  var elements = !field ? [] : field instanceof Element ? [field] : Array.from(field.values());
  return elements.filter((element) => element instanceof HTMLInputElement || element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement);
}
function getEventTarget(form, name, value) {
  var _elements$;
  var elements = getFieldElements(form, name);
  if (elements.length > 1) {
    var options = typeof value === "string" ? [value] : value;
    for (var element of elements) {
      if (typeof options !== "undefined" && element instanceof HTMLInputElement && element.type === "checkbox" && (element.checked ? options.includes(element.value) : !options.includes(element.value))) {
        continue;
      }
      return element;
    }
  }
  return (_elements$ = elements[0]) !== null && _elements$ !== void 0 ? _elements$ : null;
}
function createDummySelect(form, name, value) {
  var select = document.createElement("select");
  var options = typeof value === "string" ? [value] : value !== null && value !== void 0 ? value : [];
  select.name = name;
  select.multiple = true;
  select.dataset.conform = "true";
  select.setAttribute("aria-hidden", "true");
  select.tabIndex = -1;
  select.style.position = "absolute";
  select.style.width = "1px";
  select.style.height = "1px";
  select.style.padding = "0";
  select.style.margin = "-1px";
  select.style.overflow = "hidden";
  select.style.clip = "rect(0,0,0,0)";
  select.style.whiteSpace = "nowrap";
  select.style.border = "0";
  for (var option of options) {
    select.options.add(new Option(option, option, true, true));
  }
  form.appendChild(select);
  return select;
}
function isDummySelect(element) {
  return element.dataset.conform === "true";
}
function updateFieldValue(element, value) {
  if (element instanceof HTMLInputElement && (element.type === "checkbox" || element.type === "radio")) {
    element.checked = Array.isArray(value) ? value.includes(element.value) : element.value === value;
  } else if (element instanceof HTMLSelectElement && element.multiple) {
    var selectedValue = Array.isArray(value) ? [...value] : [value];
    for (var option of element.options) {
      var index = selectedValue.indexOf(option.value);
      var selected = index > -1;
      option.selected = selected;
      if (selected) {
        selectedValue.splice(index, 1);
      }
    }
    if (isDummySelect(element)) {
      for (var _option of selectedValue) {
        element.options.add(new Option(_option, _option, false, true));
      }
    }
  } else if (element.value !== value) {
    var {
      set: valueSetter
    } = Object.getOwnPropertyDescriptor(element, "value") || {};
    var prototype = Object.getPrototypeOf(element);
    var {
      set: prototypeValueSetter
    } = Object.getOwnPropertyDescriptor(prototype, "value") || {};
    if (prototypeValueSetter && valueSetter !== prototypeValueSetter) {
      prototypeValueSetter.call(element, value);
    } else {
      if (valueSetter) {
        valueSetter.call(element, value);
      } else {
        throw new Error("The given element does not have a value setter");
      }
    }
  }
}
function useInputEvent() {
  var ref = (0, import_react3.useRef)(null);
  var eventDispatched = (0, import_react3.useRef)({
    change: false,
    focus: false,
    blur: false
  });
  (0, import_react3.useEffect)(() => {
    var createEventListener = (listener) => {
      return (event) => {
        var element = ref.current;
        if (element && event.target === element) {
          eventDispatched.current[listener] = true;
        }
      };
    };
    var inputHandler = createEventListener("change");
    var focusHandler = createEventListener("focus");
    var blurHandler = createEventListener("blur");
    document.addEventListener("input", inputHandler, true);
    document.addEventListener("focusin", focusHandler, true);
    document.addEventListener("focusout", blurHandler, true);
    return () => {
      document.removeEventListener("input", inputHandler, true);
      document.removeEventListener("focusin", focusHandler, true);
      document.removeEventListener("focusout", blurHandler, true);
    };
  }, [ref]);
  return (0, import_react3.useMemo)(() => {
    return {
      change(value) {
        if (!eventDispatched.current.change) {
          eventDispatched.current.change = true;
          var element = ref.current;
          if (element) {
            updateFieldValue(element, value);
            element.dispatchEvent(new InputEvent("input", {
              bubbles: true
            }));
            element.dispatchEvent(new Event("change", {
              bubbles: true
            }));
          }
        }
        eventDispatched.current.change = false;
      },
      focus() {
        if (!eventDispatched.current.focus) {
          eventDispatched.current.focus = true;
          var element = ref.current;
          if (element) {
            element.dispatchEvent(new FocusEvent("focusin", {
              bubbles: true
            }));
            element.dispatchEvent(new FocusEvent("focus"));
          }
        }
        eventDispatched.current.focus = false;
      },
      blur() {
        if (!eventDispatched.current.blur) {
          eventDispatched.current.blur = true;
          var element = ref.current;
          if (element) {
            element.dispatchEvent(new FocusEvent("focusout", {
              bubbles: true
            }));
            element.dispatchEvent(new FocusEvent("blur"));
          }
        }
        eventDispatched.current.blur = false;
      },
      register(element) {
        ref.current = element;
      }
    };
  }, []);
}
function useInputValue(options) {
  var initializeValue = () => {
    var _options$initialValue;
    if (typeof options.initialValue === "string") {
      return options.initialValue;
    }
    return (_options$initialValue = options.initialValue) === null || _options$initialValue === void 0 ? void 0 : _options$initialValue.map((value2) => value2 !== null && value2 !== void 0 ? value2 : "");
  };
  var [key, setKey] = (0, import_react3.useState)(options.key);
  var [value, setValue] = (0, import_react3.useState)(initializeValue);
  if (key !== options.key) {
    setValue(initializeValue);
    setKey(options.key);
  }
  return [value, setValue];
}
function useControl(meta) {
  var [value, setValue] = useInputValue(meta);
  var {
    register,
    change,
    focus,
    blur
  } = useInputEvent();
  var handleChange = (value2) => {
    setValue(value2);
    change(value2);
  };
  var refCallback = (element) => {
    var _meta$key;
    register(element);
    if (!element) {
      return;
    }
    var prevKey = element.dataset.conform;
    var nextKey = "".concat((_meta$key = meta.key) !== null && _meta$key !== void 0 ? _meta$key : "");
    if (prevKey !== nextKey) {
      element.dataset.conform = nextKey;
      updateFieldValue(element, value !== null && value !== void 0 ? value : "");
    }
  };
  return {
    register: refCallback,
    value,
    change: handleChange,
    focus,
    blur
  };
}
function useInputControl(meta) {
  var [value, setValue] = useInputValue(meta);
  var initializedRef = (0, import_react3.useRef)(false);
  var {
    register,
    change,
    focus,
    blur
  } = useInputEvent();
  (0, import_react3.useEffect)(() => {
    var form = getFormElement(meta.formId);
    if (!form) {
      console.warn("useInputControl is unable to find form#".concat(meta.formId, " and identify if a dummy input is required"));
      return;
    }
    var element = getEventTarget(form, meta.name);
    if (!element && typeof value !== "undefined" && (!Array.isArray(value) || value.length > 0)) {
      element = createDummySelect(form, meta.name, value);
    }
    register(element);
    if (!initializedRef.current) {
      initializedRef.current = true;
    } else {
      change(value !== null && value !== void 0 ? value : "");
    }
    return () => {
      register(null);
      var elements = getFieldElements(form, meta.name);
      for (var _element of elements) {
        if (isDummySelect(_element)) {
          _element.remove();
        }
      }
    };
  }, [meta.formId, meta.name, value, change, register]);
  return {
    value,
    change: setValue,
    focus,
    blur
  };
}
function Control(props) {
  var control = useControl(props.meta);
  return props.render(control);
}

// node_modules/@conform-to/react/helpers.mjs
function simplify(props) {
  for (var key in props) {
    if (props[key] === void 0) {
      delete props[key];
    }
  }
  return props;
}
function getAriaAttributes(metadata) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof options.ariaAttributes !== "undefined" && !options.ariaAttributes) {
    return {};
  }
  var invalid = options.ariaInvalid === "allErrors" ? !metadata.valid : typeof metadata.errors !== "undefined";
  var ariaDescribedBy = options.ariaDescribedBy;
  return simplify({
    "aria-invalid": invalid || void 0,
    "aria-describedby": invalid ? "".concat(metadata.errorId, " ").concat(ariaDescribedBy !== null && ariaDescribedBy !== void 0 ? ariaDescribedBy : "").trim() : ariaDescribedBy
  });
}
function getFormProps(metadata, options) {
  return simplify(_objectSpread2({
    id: metadata.id,
    onSubmit: metadata.onSubmit,
    noValidate: metadata.noValidate
  }, getAriaAttributes(metadata, options)));
}
function getFieldsetProps(metadata, options) {
  return simplify(_objectSpread2({
    id: metadata.id,
    name: metadata.name,
    form: metadata.formId
  }, getAriaAttributes(metadata, options)));
}
function getFormControlProps(metadata, options) {
  return simplify(_objectSpread2({
    key: metadata.key,
    required: metadata.required || void 0
  }, getFieldsetProps(metadata, options)));
}
function getInputProps(metadata, options) {
  var props = _objectSpread2(_objectSpread2({}, getFormControlProps(metadata, options)), {}, {
    type: options.type,
    minLength: metadata.minLength,
    maxLength: metadata.maxLength,
    min: metadata.min,
    max: metadata.max,
    step: metadata.step,
    pattern: metadata.pattern,
    multiple: metadata.multiple
  });
  if (typeof options.value === "undefined" || options.value) {
    if (options.type === "checkbox" || options.type === "radio") {
      props.value = typeof options.value === "string" ? options.value : "on";
      props.defaultChecked = Array.isArray(metadata.initialValue) ? metadata.initialValue.includes(options.value) : metadata.initialValue === props.value;
    } else if (typeof metadata.initialValue === "string") {
      props.defaultValue = metadata.initialValue;
    }
  }
  return simplify(props);
}
function getSelectProps(metadata) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var props = _objectSpread2(_objectSpread2({}, getFormControlProps(metadata, options)), {}, {
    multiple: metadata.multiple
  });
  if (typeof options.value === "undefined" || options.value) {
    var _metadata$initialValu;
    props.defaultValue = Array.isArray(metadata.initialValue) ? metadata.initialValue.map((item) => "".concat(item !== null && item !== void 0 ? item : "")) : (_metadata$initialValu = metadata.initialValue) === null || _metadata$initialValu === void 0 ? void 0 : _metadata$initialValu.toString();
  }
  return simplify(props);
}
function getTextareaProps(metadata) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var props = _objectSpread2(_objectSpread2({}, getFormControlProps(metadata, options)), {}, {
    minLength: metadata.minLength,
    maxLength: metadata.maxLength
  });
  if (typeof options.value === "undefined" || options.value) {
    var _metadata$initialValu2;
    props.defaultValue = (_metadata$initialValu2 = metadata.initialValue) === null || _metadata$initialValu2 === void 0 ? void 0 : _metadata$initialValu2.toString();
  }
  return simplify(props);
}
function getCollectionProps(metadata, options) {
  return options.options.map((value) => {
    var _metadata$key;
    return simplify(_objectSpread2(_objectSpread2({}, getFormControlProps(metadata, options)), {}, {
      key: "".concat((_metadata$key = metadata.key) !== null && _metadata$key !== void 0 ? _metadata$key : "").concat(value),
      id: "".concat(metadata.id, "-").concat(value),
      type: options.type,
      value,
      defaultChecked: typeof options.value === "undefined" || options.value ? options.type === "checkbox" && Array.isArray(metadata.initialValue) ? metadata.initialValue.includes(value) : metadata.initialValue === value : void 0,
      // The required attribute doesn't make sense for checkbox group
      // As it would require all checkboxes to be checked instead of at least one
      // It is overriden with `undefiend` so it could be cleaned up properly
      required: options.type === "checkbox" ? void 0 : metadata.required
    }));
  });
}
export {
  FormProvider,
  FormStateInput,
  getCollectionProps,
  getFieldsetProps,
  getFormProps,
  getInputProps,
  getSelectProps,
  getTextareaProps,
  parse,
  Control as unstable_Control,
  useControl as unstable_useControl,
  useField,
  useForm,
  useFormMetadata,
  useInputControl
};
//# sourceMappingURL=@conform-to_react.js.map
