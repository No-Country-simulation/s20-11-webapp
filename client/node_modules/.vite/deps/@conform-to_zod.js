import {
  ZodArray,
  ZodCatch,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodEffects,
  ZodIntersection,
  ZodNullable,
  ZodObject,
  ZodOptional,
  ZodPipeline,
  ZodTuple,
  ZodUnion,
  anyType,
  lazyType
} from "./chunk-K5E7SR3C.js";
import {
  formatPaths,
  parse
} from "./chunk-PZSOEYJK.js";
import "./chunk-DC5AMYBS.js";

// node_modules/@conform-to/zod/_virtual/_rollupPluginBabelHelpers.mjs
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/@conform-to/zod/constraint.mjs
var keys = ["required", "minLength", "maxLength", "min", "max", "step", "multiple", "pattern"];
function getZodConstraint(schema) {
  function updateConstraint(schema2, data) {
    var _data$name;
    var name = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var constraint = name !== "" ? (_data$name = data[name]) !== null && _data$name !== void 0 ? _data$name : data[name] = {
      required: true
    } : {};
    var def = schema2["_def"];
    if (def.typeName === "ZodObject") {
      for (var key in def.shape()) {
        updateConstraint(def.shape()[key], data, name ? "".concat(name, ".").concat(key) : key);
      }
    } else if (def.typeName === "ZodEffects") {
      updateConstraint(def.schema, data, name);
    } else if (def.typeName === "ZodPipeline") {
      updateConstraint(def.out, data, name);
    } else if (def.typeName === "ZodIntersection") {
      var leftResult = {};
      var rightResult = {};
      updateConstraint(def.left, leftResult, name);
      updateConstraint(def.right, rightResult, name);
      Object.assign(data, leftResult, rightResult);
    } else if (def.typeName === "ZodUnion" || def.typeName === "ZodDiscriminatedUnion") {
      Object.assign(data, def.options.map((option) => {
        var result2 = {};
        updateConstraint(option, result2, name);
        return result2;
      }).reduce((prev, next) => {
        var list = /* @__PURE__ */ new Set([...Object.keys(prev), ...Object.keys(next)]);
        var result2 = {};
        for (var _name of list) {
          var prevConstraint = prev[_name];
          var nextConstraint = next[_name];
          if (prevConstraint && nextConstraint) {
            var _constraint = {};
            result2[_name] = _constraint;
            for (var _key of keys) {
              if (typeof prevConstraint[_key] !== "undefined" && typeof nextConstraint[_key] !== "undefined" && prevConstraint[_key] === nextConstraint[_key]) {
                _constraint[_key] = prevConstraint[_key];
              }
            }
          } else {
            result2[_name] = _objectSpread2(_objectSpread2(_objectSpread2({}, prevConstraint), nextConstraint), {}, {
              required: false
            });
          }
        }
        return result2;
      }));
    } else if (name === "") {
      throw new Error("Unsupported schema");
    } else if (def.typeName === "ZodArray") {
      constraint.multiple = true;
      updateConstraint(def.type, data, "".concat(name, "[]"));
    } else if (def.typeName === "ZodString") {
      var _schema = schema2;
      if (_schema.minLength !== null) {
        var _schema$minLength;
        constraint.minLength = (_schema$minLength = _schema.minLength) !== null && _schema$minLength !== void 0 ? _schema$minLength : void 0;
      }
      if (_schema.maxLength !== null) {
        constraint.maxLength = _schema.maxLength;
      }
    } else if (def.typeName === "ZodOptional") {
      constraint.required = false;
      updateConstraint(def.innerType, data, name);
    } else if (def.typeName === "ZodDefault") {
      constraint.required = false;
      updateConstraint(def.innerType, data, name);
    } else if (def.typeName === "ZodNumber") {
      var _schema2 = schema2;
      if (_schema2.minValue !== null) {
        constraint.min = _schema2.minValue;
      }
      if (_schema2.maxValue !== null) {
        constraint.max = _schema2.maxValue;
      }
    } else if (def.typeName === "ZodEnum") {
      constraint.pattern = def.values.map((option) => (
        // To escape unsafe characters on regex
        option.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
      )).join("|");
    } else if (def.typeName === "ZodTuple") {
      for (var i = 0; i < def.items.length; i++) {
        updateConstraint(def.items[i], data, "".concat(name, "[").concat(i, "]"));
      }
    } else if (def.typeName === "ZodLazy") ;
  }
  var result = {};
  updateConstraint(schema, result);
  return result;
}

// node_modules/@conform-to/zod/coercion.mjs
var EMPTY_STRING = "__EMPTY_STRING__";
function coerceString(value, transform) {
  if (typeof value !== "string") {
    return value;
  }
  if (value === "") {
    return void 0;
  }
  if (value === EMPTY_STRING) {
    return "";
  }
  if (typeof transform !== "function") {
    return value;
  }
  return transform(value);
}
function coerceFile(file) {
  if (typeof File !== "undefined" && file instanceof File && file.name === "" && file.size === 0) {
    return void 0;
  }
  return file;
}
function isFileSchema(schema) {
  if (typeof File === "undefined") {
    return false;
  }
  return schema._def.effect.type === "refinement" && schema.innerType()._def.typeName === "ZodAny" && schema.safeParse(new File([], "")).success && !schema.safeParse("").success;
}
function enableTypeCoercion(type) {
  var cache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Map();
  var result = cache.get(type);
  if (result) {
    return result;
  }
  var schema = type;
  var def = type._def;
  if (def.typeName === "ZodString" || def.typeName === "ZodLiteral" || def.typeName === "ZodEnum" || def.typeName === "ZodNativeEnum") {
    schema = anyType().transform((value) => coerceString(value)).pipe(type);
  } else if (def.typeName === "ZodNumber") {
    schema = anyType().transform((value) => coerceString(value, (text) => text.trim() === "" ? text : Number(text))).pipe(type);
  } else if (def.typeName === "ZodBoolean") {
    schema = anyType().transform((value) => coerceString(value, (text) => text === "on" ? true : text)).pipe(type);
  } else if (def.typeName === "ZodDate") {
    schema = anyType().transform((value) => coerceString(value, (text) => {
      var date = new Date(text);
      if (isNaN(date.getTime())) {
        return text;
      }
      return date;
    })).pipe(type);
  } else if (def.typeName === "ZodBigInt") {
    schema = anyType().transform((value) => coerceString(value, (text) => {
      if (text.trim() === "") {
        return text;
      }
      try {
        return BigInt(text);
      } catch (_unused) {
        return text;
      }
    })).pipe(type);
  } else if (def.typeName === "ZodArray") {
    schema = anyType().transform((value) => {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "undefined" || typeof coerceFile(coerceString(value)) === "undefined") {
        return [];
      }
      return [value];
    }).pipe(new ZodArray(_objectSpread2(_objectSpread2({}, def), {}, {
      type: enableTypeCoercion(def.type, cache)
    })));
  } else if (def.typeName === "ZodObject") {
    schema = anyType().transform((value) => {
      if (typeof value === "undefined") {
        return {};
      }
      return value;
    }).pipe(new ZodObject(_objectSpread2(_objectSpread2({}, def), {}, {
      shape: () => Object.fromEntries(Object.entries(def.shape()).map((_ref) => {
        var [key, def2] = _ref;
        return [
          key,
          // @ts-expect-error see message above
          enableTypeCoercion(def2, cache)
        ];
      }))
    })));
  } else if (def.typeName === "ZodEffects") {
    if (isFileSchema(type)) {
      schema = anyType().transform((value) => coerceFile(value)).pipe(type);
    } else {
      schema = new ZodEffects(_objectSpread2(_objectSpread2({}, def), {}, {
        schema: enableTypeCoercion(def.schema, cache)
      }));
    }
  } else if (def.typeName === "ZodOptional") {
    schema = anyType().transform((value) => coerceFile(coerceString(value))).pipe(new ZodOptional(_objectSpread2(_objectSpread2({}, def), {}, {
      innerType: enableTypeCoercion(def.innerType, cache)
    })));
  } else if (def.typeName === "ZodDefault") {
    schema = anyType().transform((value) => coerceFile(coerceString(value))).pipe(new ZodDefault(_objectSpread2(_objectSpread2({}, def), {}, {
      defaultValue: () => {
        var value = def.defaultValue();
        if (value === "") {
          return EMPTY_STRING;
        }
        return value;
      },
      innerType: enableTypeCoercion(def.innerType, cache)
    })));
  } else if (def.typeName === "ZodCatch") {
    schema = new ZodCatch(_objectSpread2(_objectSpread2({}, def), {}, {
      innerType: enableTypeCoercion(def.innerType, cache)
    }));
  } else if (def.typeName === "ZodIntersection") {
    schema = new ZodIntersection(_objectSpread2(_objectSpread2({}, def), {}, {
      left: enableTypeCoercion(def.left, cache),
      right: enableTypeCoercion(def.right, cache)
    }));
  } else if (def.typeName === "ZodUnion") {
    schema = new ZodUnion(_objectSpread2(_objectSpread2({}, def), {}, {
      options: def.options.map((option) => enableTypeCoercion(option, cache))
    }));
  } else if (def.typeName === "ZodDiscriminatedUnion") {
    schema = new ZodDiscriminatedUnion(_objectSpread2(_objectSpread2({}, def), {}, {
      options: def.options.map((option) => enableTypeCoercion(option, cache)),
      optionsMap: new Map(Array.from(def.optionsMap.entries()).map((_ref2) => {
        var [discriminator, option] = _ref2;
        return [discriminator, enableTypeCoercion(option, cache)];
      }))
    }));
  } else if (def.typeName === "ZodTuple") {
    schema = new ZodTuple(_objectSpread2(_objectSpread2({}, def), {}, {
      items: def.items.map((item) => enableTypeCoercion(item, cache))
    }));
  } else if (def.typeName === "ZodNullable") {
    schema = new ZodNullable(_objectSpread2(_objectSpread2({}, def), {}, {
      innerType: enableTypeCoercion(def.innerType, cache)
    }));
  } else if (def.typeName === "ZodPipeline") {
    schema = new ZodPipeline(_objectSpread2(_objectSpread2({}, def), {}, {
      in: enableTypeCoercion(def.in, cache),
      out: enableTypeCoercion(def.out, cache)
    }));
  } else if (def.typeName === "ZodLazy") {
    var inner = def.getter();
    schema = lazyType(() => enableTypeCoercion(inner, cache));
  }
  if (type !== schema) {
    cache.set(type, schema);
  }
  return schema;
}

// node_modules/@conform-to/zod/parse.mjs
function getError(zodError, formatError) {
  var result = {};
  for (var issue of zodError.errors) {
    var name = formatPaths(issue.path);
    switch (issue.message) {
      case conformZodMessage.VALIDATION_UNDEFINED:
        return null;
      case conformZodMessage.VALIDATION_SKIPPED:
        result[name] = null;
        break;
      default: {
        var _issues = result[name];
        if (_issues !== null) {
          if (_issues) {
            result[name] = _issues.concat(issue);
          } else {
            result[name] = [issue];
          }
        }
        break;
      }
    }
  }
  return Object.entries(result).reduce((result2, _ref) => {
    var [name2, issues] = _ref;
    result2[name2] = issues ? formatError(issues) : null;
    return result2;
  }, {});
}
function parseWithZod(payload, options) {
  return parse(payload, {
    resolve(payload2, intent) {
      var errorMap = options.errorMap;
      var schema = enableTypeCoercion(typeof options.schema === "function" ? options.schema(intent) : options.schema);
      var resolveSubmission = (result) => {
        var _options$formatError;
        return {
          value: result.success ? result.data : void 0,
          error: !result.success ? getError(result.error, (_options$formatError = options.formatError) !== null && _options$formatError !== void 0 ? _options$formatError : (issues) => issues.map((issue) => issue.message)) : void 0
        };
      };
      return options.async ? schema.safeParseAsync(payload2, {
        errorMap
      }).then((result) => resolveSubmission(result)) : resolveSubmission(schema.safeParse(payload2, {
        errorMap
      }));
    }
  });
}
var conformZodMessage = {
  VALIDATION_SKIPPED: "__skipped__",
  VALIDATION_UNDEFINED: "__undefined__"
};
export {
  conformZodMessage,
  getZodConstraint,
  parseWithZod
};
//# sourceMappingURL=@conform-to_zod.js.map
